<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bluff Masters</title>
<style>
:root{
  --color-primary:#2ecc71;
  --color-dark:#ecf0f1;
}
body{
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  background:radial-gradient(circle at top,#1e335f,#000814 65%,#111 100%);
  color:var(--color-dark);
  padding:20px;min-height:100vh;
}
.container{max-width:900px;margin:auto}
.card{backdrop-filter:blur(10px);background:rgba(255,255,255,0.05);border-radius:14px;padding:20px;margin-bottom:16px;border:1px solid rgba(255,255,255,0.06)}
.top-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px}
.header h1{margin:0;font-size:1.6rem}
.btn{width:100%;padding:12px;border-radius:10px;border:none;font-weight:700;cursor:pointer;margin:8px 0}
.btn-primary{background:var(--color-primary);color:#051011}
.btn-primary:hover{box-shadow:0 0 12px rgba(46,204,113,0.9);transform:translateY(-2px)}
.btn-secondary{background:#444;color:white}
.home-image{width:100%;border-radius:12px;margin-bottom:14px;opacity:0;animation:fadeIn 1s forwards}
@keyframes fadeIn{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:none}}
.team-item{background:rgba(0,0,0,0.45);padding:12px;border-radius:10px;margin:8px 0;border:1px solid rgba(255,255,255,0.06)}
.metric-row{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-top:6px}
.metric-box{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;text-align:center;border:1px solid rgba(255,255,255,0.05)}
.bar-graph{height:8px;width:100%;background:#111;border-radius:6px;overflow:hidden;display:flex;margin-top:8px}
.bar-wins{background:#2ecc71;transition:width 1s ease}
.bar-losses{background:#e74c3c;transition:width 1s ease}
.champion-team{border:2px solid gold;animation:glow 2.2s infinite;position:relative}
.champion-team::before{content:"üëë";position:absolute;top:-10px;right:-10px;font-size:1.4rem}
@keyframes glow{0%{box-shadow:0 0 6px gold}50%{box-shadow:0 0 20px gold}100%{box-shadow:0 0 6px gold}}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:9999}
.confirm-box{background:#0f1720;padding:30px;border-radius:12px;color:#ddd;max-width:540px;text-align:center}
.confirm-title{font-size:1.4rem;margin-bottom:6px}
.confirm-message{font-size:1rem;margin-bottom:12px}
.small-muted{font-size:0.8rem;color:#9aa6ad;margin-top:10px}
.fireworks-canvas{position:fixed;inset:0;pointer-events:none;z-index:99999}
.kicker{font-weight:700;color:var(--color-primary);margin-top:8px}
</style>
</head>
<body>
<div class="container">
  <div class="top-row">
    <div class="header">
      <h1>Bluff Masters</h1>
      <div style="color:#cdd8e2;font-size:0.95rem">Track wins, series & shared stats</div>
    </div>
    <button id="homeBtn" class="btn btn-secondary" style="display:none" onclick="goHome()">üè† Home</button>
  </div>

  <!-- HOME -->
  <div id="homeScreen" class="screen active">
    <div class="card" style="text-align:center">
      <img src="bluffmasters.png" class="home-image" />
      <h2 style="margin:10px 0 12px 0">Welcome</h2>
      <button class="btn btn-primary" onclick="startNewGame()">‚ûï New Game</button>
      <button class="btn btn-secondary" onclick="showStats()">üìä View Statistics</button>
    </div>
  </div>

  <!-- Game Type -->
  <div id="gameTypeScreen" class="screen" style="display:none">
    <div class="card">
      <h2>Select Series (first to N wins)</h2>
      <button class="btn btn-primary" onclick="selectGameType(5)">First to 5 wins</button>
      <button class="btn btn-primary" onclick="selectGameType(10)">First to 10 wins</button>
      <button class="btn btn-secondary" onclick="goHome()">‚Üê Back</button>
    </div>
  </div>

  <!-- Winner -->
  <div id="winnerScreen" class="screen" style="display:none">
    <div class="card">
      <h2>Who Won?</h2>
      <button class="btn btn-primary" onclick="selectTeam('winner','Bibin & Zach')">Bibin & Zach</button>
      <button class="btn btn-primary" onclick="selectTeam('winner','Bimal & Annu')">Bimal & Annu</button>
      <button class="btn btn-primary" onclick="selectTeam('winner','Bibin & Annu')">Bibin & Annu</button>
      <button class="btn btn-primary" onclick="selectTeam('winner','Zach & Daddy')">Zach & Daddy</button>
      <button class="btn btn-primary" onclick="selectTeam('winner','Bibin & Bimal')">Bibin & Bimal</button>
      <button class="btn btn-primary" onclick="selectTeam('winner','Zach & Rikku')">Zach & Rikku</button>
      <button class="btn btn-primary" onclick="selectTeam('winner','Bibin & Daddy')">Bibin & Daddy</button>
    </div>
  </div>

  <!-- Loser -->
  <div id="loserScreen" class="screen" style="display:none">
    <div class="card">
      <h2>Who Lost?</h2>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Bibin & Zach')">Bibin & Zach</button>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Bimal & Annu')">Bimal & Annu</button>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Bibin & Annu')">Bibin & Annu</button>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Zach & Daddy')">Zach & Daddy</button>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Bibin & Bimal')">Bibin & Bimal</button>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Zach & Rikku')">Zach & Rikku</button>
      <button class="btn btn-secondary" onclick="selectTeam('loser','Bibin & Daddy')">Bibin & Daddy</button>
    </div>
  </div>

  <!-- Stats -->
  <div id="statsScreen" class="screen" style="display:none">
    <div class="card">
      <h2>Overall Statistics (Shared)</h2>

      <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:10px">
        <div style="background:linear-gradient(135deg,#3affd0,#20a56e);padding:12px;border-radius:8px;text-align:center;font-weight:700;color:#07130f">
          <div>Total Games</div><div id="totalGames">0</div>
        </div>
        <div style="background:linear-gradient(135deg,#6ec0ff,#4a7bd6);padding:12px;border-radius:8px;text-align:center;font-weight:700;color:#07130f">
          <div>Total Series Won</div><div id="totalSeries">0</div>
        </div>
      </div>

      <div id="teamStats" style="margin-top:12px"></div>

      <h3 style="margin-top:14px">Game History</h3>
      <div id="gameHistory"></div>

      <div style="margin-top:12px;display:flex;gap:8px">
        <button class="btn btn-primary" onclick="exportJSON()">‚¨áÔ∏è Export JSON</button>
        <button class="btn btn-secondary" onclick="importJSONPrompt()">‚¨ÜÔ∏è Import JSON</button>
        <button class="btn btn-secondary" onclick="goHome()">‚Üê Back</button>
      </div>

      <div style="margin-top:10px;text-align:center">
        <span style="font-size:0.85rem;opacity:0.8;cursor:pointer;text-decoration:underline" onclick="deleteLastGame()">Delete last game</span>
        &nbsp;‚Ä¢&nbsp;
        <span style="font-size:0.85rem;opacity:0.8;cursor:pointer;text-decoration:underline" onclick="resetStats()">Reset all statistics</span>
      </div>
    </div>
  </div>
</div>

<!-- confirmation modal placeholder -->
<div id="modalContainer"></div>

<!-- fireworks canvas -->
<canvas id="fireworks" class="fireworks-canvas" style="display:none"></canvas>

<script type="module">
/* =========================
   Firebase setup (non-blocking)
   ========================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
import { getFirestore, collection, addDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBdAIdEDwfoalevfadgixPTLIoLoEqi8kc",
  authDomain: "bluff-tracker-7542e.firebaseapp.com",
  projectId: "bluff-tracker-7542e",
  storageBucket: "bluff-tracker-7542e.firebasestorage.app",
  messagingSenderId: "280965687037",
  appId: "1:280965687037:web:be0b05da36ef653ab68094"
};

let db = null;
let gamesRef = null;
try {
  const app = initializeApp(firebaseConfig);
  db = getFirestore(app);
  gamesRef = collection(db, "games");
  console.log("üî• Firebase initialized (attempt).");
} catch (e) {
  console.warn("Firebase init failed:", e);
}

/* =========================
   Local model & persistence
   ========================= */
let gameData = { games: [], teamStats: {}, seriesCount: 0 };
const STORAGE_KEY = 'bluff_tracker_v1';
(function loadBackup(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw) gameData = JSON.parse(raw);
  }catch(e){ console.warn("local load failed", e); }
})();

/* rebuild stats and current series from game history */
function rebuildFromGames(){
  // reset
  gameData.teamStats = {};
  gameData.seriesCount = 0;
  // We will compute series by grouping by seriesId
  const seriesMap = {}; // seriesId => {target, games:[], wins:{} , finished, winner}
  (gameData.games || []).forEach(g=>{
    const sid = g.seriesId || 'series_'+(g.seriesStartedAt||g.time);
    if(!seriesMap[sid]) seriesMap[sid] = {target: g.seriesTarget || g.series, games: [], wins:{}, finished:false, winner:null, id:sid, startedAt: g.seriesStartedAt || g.time};
    seriesMap[sid].games.push(g);
    seriesMap[sid].wins[g.winner] = (seriesMap[sid].wins[g.winner]||0) + 1;
    // check finished
    if(seriesMap[sid].wins[g.winner] >= (seriesMap[sid].target||5) && !seriesMap[sid].finished){
      seriesMap[sid].finished = true;
      seriesMap[sid].winner = g.winner;
    }
  });
  // rebuild teamStats and consecutive series
  const teamSeriesStreak = {}; // used to compute consecutive wins
  Object.values(seriesMap).sort((a,b)=>new Date(a.startedAt)-new Date(b.startedAt)).forEach(s=>{
    if(s.finished){
      gameData.seriesCount = (gameData.seriesCount||0) + 1;
      // increment seriesWon for winner
      if(!gameData.teamStats[s.winner]) gameData.teamStats[s.winner] = {wins:0, losses:0, seriesWon:0, consecutiveSeries:0};
      gameData.teamStats[s.winner].seriesWon = (gameData.teamStats[s.winner].seriesWon||0) + 1;
      // update streaks
      teamSeriesStreak[s.winner] = (teamSeriesStreak[s.winner]||0) + 1;
      // reset streaks for others
      Object.keys(teamSeriesStreak).forEach(t=>{ if(t!==s.winner) teamSeriesStreak[t]=0; });
      gameData.teamStats[s.winner].consecutiveSeries = teamSeriesStreak[s.winner];
      // ensure losers exist in teamStats
      const losers = new Set();
      s.games.forEach(g=>{ if(g.loser) losers.add(g.loser); });
      losers.forEach(l=>{
        if(!gameData.teamStats[l]) gameData.teamStats[l] = {wins:0, losses:0, seriesWon:0, consecutiveSeries:0};
      });
    } else {
      // ongoing series: we still want the wins/losses included in team counts
      s.games.forEach(g=>{
        if(!gameData.teamStats[g.winner]) gameData.teamStats[g.winner] = {wins:0, losses:0, seriesWon:0, consecutiveSeries:0};
        if(!gameData.teamStats[g.loser]) gameData.teamStats[g.loser] = {wins:0, losses:0, seriesWon:0, consecutiveSeries:0};
        gameData.teamStats[g.winner].wins = (gameData.teamStats[g.winner].wins||0) + 1;
        gameData.teamStats[g.loser].losses = (gameData.teamStats[g.loser].losses||0) + 1;
      });
    }
  });

  // if no series finished, but games exist, still accumulate wins/losses
  if(Object.keys(seriesMap).length===0){
    (gameData.games||[]).forEach(g=>{
      if(!gameData.teamStats[g.winner]) gameData.teamStats[g.winner] = {wins:0,losses:0,seriesWon:0,consecutiveSeries:0};
      if(!gameData.teamStats[g.loser]) gameData.teamStats[g.loser] = {wins:0,losses:0,seriesWon:0,consecutiveSeries:0};
      gameData.teamStats[g.winner].wins = (gameData.teamStats[g.winner].wins||0) + 1;
      gameData.teamStats[g.loser].losses = (gameData.teamStats[g.loser].losses||0) + 1;
    });
  }

  // Save backup
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData)); }catch(e){console.warn("save backup failed",e);}
}

/* initial rebuild */
rebuildFromGames();

/* =========================
   UI helpers & flow
   ========================= */
function showScreen(id){
  document.querySelectorAll('.screen').forEach(s=>s.style.display='none');
  const el = document.getElementById(id);
  if(el) el.style.display='block';
  document.getElementById('homeBtn').style.display=(id==='homeScreen')?'none':'inline-block';
}
window.goHome = ()=> showScreen('homeScreen');

window.startNewGame = () => {
  // start a new series context
  window.currentSeries = {
    seriesId: 'series_' + Date.now(),
    seriesTarget: null,
    startedAt: new Date().toISOString(),
    wins: {}
  };
  window.currentGame = {};
  showScreen('gameTypeScreen');
};

window.selectGameType = t => {
  if(!window.currentSeries) window.startNewGame();
  window.currentSeries.seriesTarget = t;
  showScreen('winnerScreen');
};

window.selectTeam = async (role, team) => {
  if(role === 'winner'){
    window.currentGame = window.currentGame || {};
    window.currentGame.winner = team;
    showScreen('loserScreen');
    return;
  }
  // loser branch
  if(!window.currentGame || !window.currentGame.winner){
    alert('Pick winner first'); return;
  }
  if(team === window.currentGame.winner){
    alert('Winner and loser cannot be same'); return;
  }

  window.currentGame.loser = team;

  // build record including series metadata
  const rec = {
    winner: window.currentGame.winner,
    loser: window.currentGame.loser,
    seriesTarget: window.currentSeries.seriesTarget || 5,
    seriesId: window.currentSeries.seriesId,
    seriesStartedAt: window.currentSeries.startedAt,
    time: new Date().toISOString()
  };

  // local optimistic push
  gameData.games.push(rec);
  // recalc stats from history (safe)
  rebuildFromGames();
  // show immediate confirmation modal with series progress message (non-blocking)
  const msg = buildSeriesProgressMessage(rec);
  showConfirmationLarge("‚úÖ Game Saved", msg, ()=>{ /* on ok: show stats */ showStats(); });

  // play confetti/fireworks based on punchy outcomes
  maybeShowGraphics(rec);

  // persist local backup
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData)); }catch(e){console.warn("backup save failed", e);}

  // non-blocking cloud write with timeout
  if(gamesRef){
    try {
      await Promise.race([
        addDoc(gamesRef, rec),
        new Promise((_, reject) => setTimeout(()=>reject(new Error('FirebaseTimeout')), 2000))
      ]);
      console.log('‚òÅÔ∏è Game saved to Firestore', rec);
      // if series finished, also write series result collection
      if(checkSeriesFinishedInRecord(rec)){
        // write seriesResult doc (best-effort)
        try{
          const seriesCollection = collection(db, 'seriesResults');
          await Promise.race([
            addDoc(seriesCollection, {
              seriesId: rec.seriesId,
              winner: rec.winner,
              target: rec.seriesTarget,
              finishedAt: new Date().toISOString()
            }),
            new Promise((_, reject) => setTimeout(()=>reject(new Error('FirebaseTimeout')),2000))
          ]);
        }catch(e){ console.warn('Could not write series result', e); }
      }
    } catch (err) {
      console.warn('‚ö†Ô∏è Firebase save failed or timed out:', err);
    }
  } else {
    console.log('No Firebase configured ‚Äî operating locally only.');
  }

  // if series finished, reset currentSeries (start fresh next time)
  if(checkSeriesFinishedInRecord(rec)){
    // update team stats seriesWon already handled in rebuildFromGames()
    // prepare for next series automatically
    window.currentSeries = null;
  } else {
    // update currentSeries wins
    window.currentSeries.wins[rec.winner] = (window.currentSeries.wins[rec.winner]||0) + 1;
  }

  // clear currentGame for next selection
  window.currentGame = {};
};

/* helper: check series finished from entire history for this record's seriesId */
function checkSeriesFinishedInRecord(rec){
  const sid = rec.seriesId;
  const target = rec.seriesTarget;
  let wins = {};
  gameData.games.forEach(g=>{
    if(g.seriesId===sid){
      wins[g.winner] = (wins[g.winner]||0) + 1;
      if(wins[g.winner] >= target) return;
    }
  });
  return Object.values(wins).some(c=>c>=target);
}

/* build the big confirmation message including "X more wins to reach series" or series victory */
function buildSeriesProgressMessage(rec){
  // find current wins in that series
  const sid = rec.seriesId;
  const target = rec.seriesTarget;
  const wins = {};
  (gameData.games||[]).forEach(g=>{ if(g.seriesId===sid) wins[g.winner] = (wins[g.winner]||0) + 1; });
  const winnerWins = wins[rec.winner]||0;
  const loserWins = wins[rec.loser]||0;
  const remaining = Math.max(0, target - winnerWins);
  // if series finished
  if(winnerWins >= target){
    // determine margin
    const scoreLine = `${winnerWins}-${loserWins}`;
    // check perfect sweep
    if(loserWins===0){
      return `<div class="confirm-message"><b>FLAWLESS VICTORY! ${scoreLine}!</b><br>${rec.winner} sweeps the series!</div><div class="kicker">üî• Epic! Fireworks incoming!</div>`;
    } else {
      // check consecutive series streak message
      const s = (gameData.teamStats[rec.winner] && gameData.teamStats[rec.winner].consecutiveSeries) || 1;
      if(s>=2){
        return `<div class="confirm-message"><b>üèÜ Series Won ‚Äî ${scoreLine}</b><br>Yaay.. Another fabulous series ‚Äî ${rec.winner} beat ${rec.loser}. You Won ${s} Series against them! All the best for a Hat-Trick!</div>`;
      }
      return `<div class="confirm-message"><b>üèÜ Series Won ‚Äî ${scoreLine}</b><br>${rec.winner} wins this series! Great work.</div>`;
    }
  } else {
    return `<div class="confirm-message"><b>${rec.winner} beat ${rec.loser}</b><br>${rec.winner} needs <b>${remaining}</b> more win${remaining===1?'':'s'} to reach ${target} wins in this series.</div>`;
  }
}

/* show confirmation modal (large) */
function showConfirmationLarge(title, htmlMessage, onOk){
  closeModal();
  const overlay = document.createElement('div'); overlay.className='overlay';
  const box = document.createElement('div'); box.className='confirm-box';
  box.innerHTML = `<div class="confirm-title">${title}</div>${htmlMessage}`;
  const btn = document.createElement('button'); btn.className='btn btn-primary'; btn.innerText='OK';
  btn.onclick = function(){ closeModal(); if(onOk) onOk(); };
  box.appendChild(btn);
  box.appendChild(Object.assign(document.createElement('div'), {className:'small-muted', innerText:'Saved locally and syncing to cloud (if available).'}));
  overlay.appendChild(box);
  document.getElementById('modalContainer').appendChild(overlay);
}

/* generic close */
function closeModal(){ const c=document.getElementById('modalContainer'); c.innerHTML=''; }

/* show regular stats screen */
window.showStats = ()=>{ showScreen('statsScreen'); updateStatsUI(); };

/* graphics: confetti and fireworks */
function simpleConfetti(){
  // small confetti at center
  const canvas = document.createElement('canvas');
  canvas.style.position='fixed'; canvas.style.left=0; canvas.style.top=0;
  canvas.style.width='100%'; canvas.style.height='100%'; canvas.style.zIndex=99998; canvas.style.pointerEvents='none';
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  resize(); window.addEventListener('resize', resize);
  const colors=['#ffdd57','#ff6b6b','#44ff8a','#6ec0ff','#ff9ce3'];
  const p=[];
  for(let i=0;i<80;i++){
    p.push({x:Math.random()*canvas.width,y:-Math.random()*canvas.height,w:6+Math.random()*10,h:6+Math.random()*10,vx:-2+Math.random()*4,vy:2+Math.random()*4,color:colors[Math.floor(Math.random()*colors.length)],rot:Math.random()*360,vr:-5+Math.random()*10});
  }
  let last = performance.now();
  function frame(t){
    const dt = (t-last)/16.67; last=t;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    p.forEach(a=>{
      a.x += a.vx*dt; a.y += a.vy*dt; a.vy += 0.05*dt; a.rot += a.vr*dt;
      ctx.save(); ctx.translate(a.x,a.y); ctx.rotate(a.rot*Math.PI/180);
      ctx.fillStyle = a.color; ctx.fillRect(-a.w/2,-a.h/2,a.w,a.h); ctx.restore();
    });
    if(p.every(a=>a.y>canvas.height+50)){ window.removeEventListener('resize', resize); canvas.remove(); return; }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

function startFireworks(duration = 2500){
  const canvas = document.getElementById('fireworks');
  if(!canvas) return;
  canvas.style.display='block';
  const ctx = canvas.getContext('2d');
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  resize(); window.addEventListener('resize', resize);
  const fireworks = [];
  function spawn(){
    const x = Math.random()*canvas.width;
    const y = Math.random()*canvas.height*0.6;
    const count = 30 + Math.round(Math.random()*40);
    const hue = Math.round(Math.random()*360);
    for(let i=0;i<count;i++){
      const speed = Math.random()*4 + 1;
      const angle = Math.random()*Math.PI*2;
      fireworks.push({
        x,y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        life: 60 + Math.round(Math.random()*40),
        color: `hsl(${hue} ${60+Math.round(Math.random()*40)}% ${40+Math.round(Math.random()*40)}%)`
      });
    }
  }
  let last = performance.now();
  function frame(t){
    const dt = (t-last)/16.67; last=t;
    ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let i=fireworks.length-1;i>=0;i--){
      const p = fireworks[i];
      p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 0.06*dt;
      p.life--;
      ctx.beginPath(); ctx.fillStyle = p.color; ctx.arc(p.x,p.y, Math.max(0, Math.min(3, p.life/10)), 0, Math.PI*2); ctx.fill();
      if(p.life<=0) fireworks.splice(i,1);
    }
    requestAnimationFrame(frame);
  }
  const spawnInt = setInterval(spawn, 250);
  requestAnimationFrame(frame);
  setTimeout(()=>{ clearInterval(spawnInt); setTimeout(()=>{ canvas.style.display='none'; }, 1200); }, duration);
}

/* choose which graphic to show */
function maybeShowGraphics(rec){
  // if series finished and sweep
  const sid = rec.seriesId; const target = rec.seriesTarget;
  let wins = {};
  gameData.games.forEach(g=>{ if(g.seriesId===sid) wins[g.winner] = (wins[g.winner]||0) + 1; });
  const winnerWins = wins[rec.winner]||0;
  const loserWins = wins[rec.loser]||0;
  if(winnerWins >= target && loserWins === 0){
    // sweep
    startFireworks(3000);
  } else {
    // always show confetti for game saved
    simpleConfetti();
  }
}

/* =========================
   Delete / Reset (password protected)
   ========================= */
function deleteLastGame(){
  if(!(gameData.games && gameData.games.length)) { alert("No games to delete."); return; }
  const pw = prompt("Enter password to delete last game:");
  if(pw !== "zachariahrenji"){ alert("‚ùå Incorrect password"); return; }
  if(!confirm("Delete the most recent game permanently?")) return;
  gameData.games.pop();
  rebuildFromGames();
  localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
  showConfirmationLarge("‚úÖ Last Game Deleted", `<div class="confirm-message">Last game removed from history.</div>`, ()=> showStats());
}

function resetStats(){
  const pw = prompt("Enter password to reset all data:");
  if(pw !== "zachariahrenji"){ alert("‚ùå Incorrect password"); return; }
  if(!confirm("‚ö†Ô∏è This will permanently delete ALL stats. Continue?")) return;
  gameData = { games: [], teamStats: {}, seriesCount: 0 };
  localStorage.removeItem(STORAGE_KEY);
  // Optionally: try deleting from Firestore? not performed here (requires admin)
  showConfirmationLarge("‚úÖ Reset Complete", `<div class="confirm-message">All statistics erased locally. Cloud data unchanged.</div>`, ()=> showStats());
}

/* =========================
   Import / Export JSON (simple)
   ========================= */
function exportJSON(){
  const blob = new Blob([JSON.stringify(gameData, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'bluff-tracker-backup.json'; a.click();
}
function importJSONPrompt(){
  const input = document.createElement('input'); input.type='file'; input.accept='application/json';
  input.onchange = (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ()=> {
      try {
        const parsed = JSON.parse(r.result);
        if(parsed && Array.isArray(parsed.games)){
          if(confirm('Importing will replace local history. Continue?')){
            gameData = parsed;
            rebuildFromGames();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
            alert('Import complete.');
            showStats();
          }
        } else alert('Invalid file format.');
      } catch(ex){ alert('Failed to parse file.'); }
    };
    r.readAsText(f);
  };
  input.click();
}

/* =========================
   Live Firestore sync (listens for changes and replaces local canonical data)
   ========================= */
if(gamesRef){
  try{
    onSnapshot(gamesRef, snapshot=>{
      // snapshot may contain many docs; convert to array
      const docs = snapshot.docs.map(d => d.data());
      // sort chronologically
      docs.sort((a,b)=> new Date(a.time) - new Date(b.time));
      // replace local gameData.games with cloud canonical list BUT keep local-only games if any (we won't merge to avoid duplicates)
      // For simplicity: we'll set local history to cloud docs
      gameData.games = docs;
      rebuildFromGames();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
      console.log('üîÅ Synced games from Firestore. Total:', gameData.games.length);
    }, err=>{
      console.warn('Firestore snapshot error:', err);
    });
  } catch(e){ console.warn('onSnapshot failed:', e); }
}

/* =========================
   UI: update stats panel from gameData
   ========================= */
function updateStatsUI(){
  document.getElementById('totalGames').textContent = (gameData.games||[]).length;
  document.getElementById('totalSeries').textContent = (gameData.seriesCount||0);
  const teams = Object.keys(gameData.teamStats||{}).sort((a,b)=> (gameData.teamStats[b].wins||0)-(gameData.teamStats[a].wins||0));
  let html = '';
  teams.forEach((team, idx)=>{
    const s = gameData.teamStats[team];
    const w = s.wins||0, l = s.losses||0, sw = s.seriesWon||0, cs = s.consecutiveSeries||0;
    const total = w + l; const wp = total?Math.round((w/total)*100):0; const lp = 100-wp;
    html += `<div class="team-item ${idx===0?'champion-team':''}">
      <div class="team-name">${team}</div>
      <div class="metric-row">
        <div class="metric-box"><div class="metric-label">Wins</div><div class="metric-value">${w}</div></div>
        <div class="metric-box"><div class="metric-label">Losses</div><div class="metric-value">${l}</div></div>
        <div class="metric-box"><div class="metric-label">Series</div><div class="metric-value">${sw||0}${cs>0?` <small>(${cs} streak)</small>`:''}</div></div>
        <div class="metric-box"><div class="metric-label">Win %</div><div class="metric-value">${wp}%</div></div>
      </div>
      <div class="bar-graph"><div class="bar-wins" style="width:${wp}%"></div><div class="bar-losses" style="width:${lp}%"></div></div>
    </div>`;
  });
  document.getElementById('teamStats').innerHTML = html || '<div style="color:#cfd8e3">No teams yet</div>';

  const hist = (gameData.games||[]).slice().reverse().map(g=>{
    return `<div style="background:rgba(255,255,255,0.06);padding:10px;margin:8px 0;border-radius:10px;">
      <small>${new Date(g.time).toLocaleString()}</small><br><b>${g.winner}</b> beat <b>${g.loser}</b> <small style="opacity:0.7">[series target:${g.seriesTarget || g.series}]</small>
    </div>`;
  }).join('');
  document.getElementById('gameHistory').innerHTML = hist || '<div style="color:#cfd8e3">No games yet</div>';
}

/* expose updateStatsUI globally for convenience */
window.updateStatsUI = updateStatsUI;

/* initial UI populate */
updateStatsUI();

console.log("‚úÖ Bluff Masters loaded. Local backup present. Firebase (if configured) will sync in background.");

</script>
</body>
</html>
